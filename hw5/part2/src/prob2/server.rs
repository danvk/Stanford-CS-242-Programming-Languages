/* DO NOT EDIT THIS FILE. */

/***************
 * NOTE:
 *   To implement `client.rs`, you only need to understand
 *   the signature and specification of `internal_send_sig` and `internal_send_pkts`.
 *   You do not need to understand other parts.
 ***************/

use crate::prob2::msg::{Sig, Pkt};
use rand::prelude::*;

/******************
 * Defn of Server *
 ******************/
pub struct Server {
    state       : ServerState,
    ids_recved  : Vec<u32>,
    recv_type   : RecvType,
    recv_alter  : bool,
    recv_rng    : StdRng,
    recv_rej_cnt: u32,
}

pub enum RecvType {
    All,   // receives all signals and packets.
    Alter, // receives every other signal and packet.
    Rand,  // receives signals and packets at random.
}

enum ServerState {
    Init, Syned, SynAcked, Closed,
}

impl Server {
    // return a new server.
    pub fn new(recv_type: RecvType) -> Server {
        Server {
            state       : ServerState::Init,
            ids_recved  : Vec::new(),
            recv_type   : recv_type,
            recv_alter  : false,
            recv_rng    : StdRng::seed_from_u64(0),
            recv_rej_cnt: 0,
        }
    }

    // return the packets received by `self`.
    pub fn ids_recved(&self) -> Vec<u32> { self.ids_recved.clone() }

    // return `true`, if `self` is connected to some client.
    // return `false`, otherwise.
    pub fn is_connected(&self) -> bool {
        match self.state {
            ServerState::Init => false,
            _ => true,
        }
    }

    // every server will accept all packets after rejecting `RECV_REJ_MAX` packets.
    const RECV_REJ_MAX: u32 = 100;

    // return `true`, if `self` decided to receive the incoming msg.
    // return `false`, otherwise.
    fn should_recv_msg(&mut self) -> bool {
        match self.recv_type {
            RecvType::All  => {
                true
            },
            RecvType::Alter => {
                let res = self.recv_alter;
                self.recv_alter = !res;
                res
            },
            RecvType::Rand => {
                let res = self.recv_rng.gen_bool(0.5)
                    || self.recv_rej_cnt >= Server::RECV_REJ_MAX;
                if !res { self.recv_rej_cnt += 1; }
                res
            },
        }
    }
}

/*****************
 * Ops on Server *
 *****************/
/* internal_send_sig(server, sig):
 *   - send `sig` to `server`.
 *   - return `Some(sig_ret)`, if `server` sends `sig_ret` back to client,
 *     return `None`, if `server` sends nothing back to client.
 *   - abort with error message, if `server` receives invalid `sig`. */
pub(in crate::prob2) fn internal_send_sig(server: &mut Server, sig: Sig) -> Option<Sig> {
    fn raise_err(sig_sent:Sig, sig_valid: Sig) -> Option<Sig> {
        panic!("[ERROR] server received {:?}, but now accepts only {:?}.",
               sig_sent, sig_valid)
    }
    match (&server.state, &sig){
        (ServerState::Init, Sig::Syn) =>
            if server.should_recv_msg() {
                // println!("server received: {:?}", sig);
                server.state = ServerState::Syned;
                Some(Sig::SynAck)
            } else {
                None
            },
        (ServerState::Syned, Sig::Ack) => {
            // println!("server received: {:?}", sig);
            server.state = ServerState::SynAcked;
            None
        },
        (ServerState::SynAcked, Sig::Close) =>
            if server.should_recv_msg() {
                // println!("server received: {:?}", sig);
                server.state = ServerState::Closed;
                Some(Sig::CloseAck)
            } else {
                None
            },
        (ServerState::Closed, Sig::Ack) => {
            // println!("server received: {:?}", sig);
            server.state = ServerState::Init;
            None
        },
        (ServerState::Init,     _) => raise_err(sig, Sig::Syn),
        (ServerState::Syned,    _) => raise_err(sig, Sig::Ack),
        (ServerState::SynAcked, _) => raise_err(sig, Sig::Close),
        (ServerState::Closed,   _) => raise_err(sig, Sig::Ack),
    }
}

/* internal_send_pkts(server, sig):
 *   - send `pkts` to `server`.
 *   - return a vector of ids of the packets that `server` received. */
pub(in crate::prob2) fn internal_send_pkts(server: &mut Server, pkts: &Vec<Pkt>) -> Vec<u32> {
    let mut ids_recved: Vec<u32> = Vec::new();
    for pkt in pkts.iter() {
        if server.should_recv_msg() {
            // println!("server received: {:?}", pkt);
            server.ids_recved.push(pkt.id);
            ids_recved.push(pkt.id);
        }
    }
    ids_recved
}
