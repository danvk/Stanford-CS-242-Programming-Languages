

# Usage:
# - set
#   - you send a private channel to set
#   - then you send the value you want to set to that channel
#   - (receives the current value from the store, sends a new value)
# - get
#   - send a private channel to get
#   - get sends the current value to that channel.
#   - (sends the same value back to the store)
# Idea: maintain a private channel with the current value as a pending message

def VALUE = &store. (
    # initial set
    c <- set. v <- c. v -> store. 0
    |
    # subsequent state
    !v <- store. (
        (c <- get. v -> store. v -> c. 0)
        +
        (c <- set. new <- set. new -> store. 0)
    )
);

# Some tests.
def GET = &req. req -> get. current <- req. current -> result. 0;
def SET_A_GET = &req. req -> set. a -> req. GET;
def SET_AB_GET = &req. req -> set. a -> req. &req. req -> set. b -> req. GET;
def SET_A_or_B_GET = &finished. (&req. req -> set. a -> req. void -> finished.0 |
                                 &req. req -> set. b -> req. void -> finished.0 |
                                 _ <- finished. _ <- finished. GET);

def GET_GET = &req. req -> get. current <- req. current -> result1. 0
            | &req. req -> get. current <- req. current -> result2. 0;
def SET_A_GET_GET = &req. req -> set. a -> req. GET_GET;

# Expected Output:
#   a -> result. 0
# | ...
VALUE | SET_A_GET;


# Expected Output:
#   b -> result. 0
# | ...
VALUE | SET_AB_GET;

# This tests two concurrent requests. The result depends on non-deterministic choice
# Expected Output:
# --- State 0 ---
#   a -> result. 0
# | ...
# --- State 1 ---
#   b -> result. 0
# | ...
VALUE | SET_A_or_B_GET;

# Expected Output:
#   a -> result1. 0
# | a -> result2. 0
# | ...
VALUE | SET_A_GET_GET;


